06 | setState 是同步更新还是异步更新？
<div data-v-39db28e6="" class="main-container"><div data-v-39db28e6="" class="rich-text-wrap"><p data-nodeid="8348" class="">本讲我们一起来探讨“setState 是同步更新还是异步更新”，这个问题在面试中应该如何回答。</p>
<h3 data-nodeid="8349">破题</h3>
<p data-nodeid="8350">“是 A 还是 B ”是一个在面试中经常会被问到的问题类型，这类问题有相当强的迷惑性，因为在不同的场景中会有不同的选择：</p>
<ul data-nodeid="8351">
<li data-nodeid="8352">
<p data-nodeid="8353">可能是 A；</p>
</li>
<li data-nodeid="8354">
<p data-nodeid="8355">也可能是 B；</p>
</li>
<li data-nodeid="8356">
<p data-nodeid="8357">甚至 A 和 B 同时存在的可能性也是有的。</p>
</li>
</ul>
<p data-nodeid="8358">所以就需要把问题放在具体的场景中探讨，才能有更加全面准确的回答。在面对类似的问题时，要先把场景理清楚，再去思考如何回答，一定不要让自己犯“想当然”的错误。这是回答类似问题第一个需要注意的点。</p>
<p data-nodeid="8359">回到 setState 本身上来，setState 用于变更状态，触发组件重新渲染，更新视图 UI。有很多应聘者，并不清楚 state 在什么时候会被更新，所以难以解释到底是同步的还是异步的，也不清楚这个问题具体涉及哪些概念？</p>
<p data-nodeid="8360">本题也是大厂面试中的一道高频题，常被用作检验应聘者的资深程度。</p>
<p data-nodeid="8361">以上就是这个问题的“碎碎念”了，接下来是整理答题思路。</p>
<h3 data-nodeid="8362">承题</h3>
<p data-nodeid="8363">回到问题本身上来，其实思路很简单，只要能说清楚什么是同步场景，什么是异步场景，那问题自然而然就解决了。</p>
<p data-nodeid="8364"><img src="https://s0.lgstatic.com/i/image2/M01/01/3D/Cip5yF_YUpOAALIlAABNx0PyF94306.png" alt="Drawing 1.png" data-nodeid="8462"></p>
<h3 data-nodeid="8365">入手</h3>
<p data-nodeid="8366">在分析场景之前，需要先补充一个很重要的知识点，即合成事件，同样它也是 React 面试中很容易被考察的点。合成事件与 setState 的触发更新有千丝万缕的关系，也只有在了解合成事件后，我们才能继续聊 setState。</p>
<h4 data-nodeid="8367">合成事件</h4>
<p data-nodeid="8368">在没有合成事件前，大家是如何处理事件的呢？由于很多同学都是直接从 React 和 Vue 开始入门的，所以很可能不太清楚这样一个在过去非常常见的场景。</p>
<p data-nodeid="8369">假设一个列表的 ul 标签下面有 10000 个 li 标签。现在需要添加点击事件，通过点击获取当前 li 标签中的文本。那该如何操作？如果按照现在 React 的编写方式，就是为每一个 li 标签添加 onclick 事件。有 10000 个 li 标签，则会添加 10000 个事件。这是一种非常不友好的方式，会对页面的性能产生影响。</p>
<div class="course-code-area"><div class="copy-btn"><div class="copy-icon"></div>复制代码</div><pre><code data-language="java"><ol><li><div class="code-word">&lt;ul&gt;
</div></li><li><div class="code-word">  &lt;li onclick="geText(this)"&gt;1&lt;/li&gt;
</div></li><li><div class="code-word">  &lt;li onclick="geText(this)"&gt;2&lt;/li&gt;
</div></li><li><div class="code-word">  &lt;li onclick="geText(this)"&gt;3&lt;/li&gt;
</div></li><li><div class="code-word">  &lt;li onclick="geText(this)"&gt;4&lt;/li&gt;
</div></li><li><div class="code-word">  &lt;li onclick="geText(this)"&gt;5&lt;/li&gt;
</div></li><li><div class="code-word">  &nbsp;...
</div></li><li><div class="code-word">  &lt;li onclick="geText(this)"&gt;10000&lt;/li&gt;
</div></li><li><div class="code-word">&lt;/ul&gt;
</div></li></ol></code></pre></div>
<p data-nodeid="8371">那该怎么优化呢？最恰当的处理方式是采用<strong data-nodeid="8473">事件委托</strong>。通过将事件绑定在 ul 标签上这样的方式来解决。当 li 标签被点击时，由事件冒泡到父级的 ul 标签去触发，并在 ul 标签的 onclick 事件中，确认是哪一个 li 标签触发的点击事件。</p>
<div class="course-code-area"><div class="copy-btn"><div class="copy-icon"></div>复制代码</div><pre><code data-language="java"><ol><li><div class="code-word">&lt;ul id="test"&gt;
</div></li><li><div class="code-word">  &lt;li&gt;1&lt;/li&gt;
</div></li><li><div class="code-word">  &lt;li&gt;2&lt;/li&gt;
</div></li><li><div class="code-word">  &lt;li&gt;3&lt;/li&gt;
</div></li><li><div class="code-word">  &lt;li&gt;4&lt;/li&gt;
</div></li><li><div class="code-word">  &lt;li&gt;5&lt;/li&gt;
</div></li><li><div class="code-word">  &lt;li&gt;10000&lt;/li&gt;
</div></li><li><div class="code-word">&lt;/ul&gt;
</div></li><li><div class="code-word">&lt;script&gt;
</div></li><li><div class="code-word">  function getEventTarget(e) {
</div></li><li><div class="code-word">      e = e || window.event;
</div></li><li><div class="code-word">      return e.target || e.srcElement; 
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">  var ul = document.getElementById('test');
</div></li><li><div class="code-word">  ul.onclick = function(event) {
</div></li><li><div class="code-word">      var target = getEventTarget(event);
</div></li><li><div class="code-word">      alert(target.innerHTML);
</div></li><li><div class="code-word">  };
</div></li><li><div class="code-word">&lt;/script&gt;
</div></li></ol></code></pre></div>
<p data-nodeid="8373">同样，出于性能考虑，合成事件也是如此：</p>
<ul data-nodeid="8374">
<li data-nodeid="8375">
<p data-nodeid="8376">React 给 document 挂上事件监听；</p>
</li>
<li data-nodeid="8377">
<p data-nodeid="8378">DOM 事件触发后冒泡到 document；</p>
</li>
<li data-nodeid="8379">
<p data-nodeid="8380">React 找到对应的组件，造出一个合成事件出来；</p>
</li>
<li data-nodeid="8381">
<p data-nodeid="8382">并按组件树模拟一遍事件冒泡。</p>
</li>
</ul>
<p data-nodeid="8383"><img src="https://s0.lgstatic.com/i/image2/M01/01/3E/CgpVE1_YUqKAA-jWAACt3Mh2xk8536.png" alt="Drawing 2.png" data-nodeid="8481"></p>
<div data-nodeid="8384"><p style="text-align:center">React 17 之前的事件冒泡流程图</p></div>
<p data-nodeid="8385">所以这就造成了，在一个页面中，只能有一个版本的 React。如果有多个版本，事件就乱套了。值得一提的是，这个问题在 React 17 中得到了解决，事件委托不再挂在 document 上，而是挂在 DOM 容器上，也就是 ReactDom.Render 所调用的节点上。</p>
<p data-nodeid="8386"><img src="https://s0.lgstatic.com/i/image2/M01/01/3E/Cip5yF_YUzCAWTyoAAB1ljK7rSM539.png" alt="Drawing 3.png" data-nodeid="8485"></p>
<div data-nodeid="8387"><p style="text-align:center">React 17 后的事件冒泡流程图</p></div>
<p data-nodeid="8388">那到底哪些事件会被捕获生成合成事件呢？可以从 React 的源码测试文件中一探究竟。下面的测试快照中罗列了大量的事件名，也只有在这份快照中的事件，才会被捕获生成合成事件。</p>
<div class="course-code-area"><div class="copy-btn"><div class="copy-icon"></div>复制代码</div><pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-comment">// react/packages/react-dom/src/__tests__/__snapshots__/ReactTestUtils-test.js.snap</span>
</div></li><li><div class="code-word">Array [
</div></li><li><div class="code-word">	  <span class="hljs-string">"abort"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"animationEnd"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"animationIteration"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"animationStart"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"auxClick"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"beforeInput"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"blur"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"canPlay"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"canPlayThrough"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"cancel"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"change"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"click"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"close"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"compositionEnd"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"compositionStart"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"compositionUpdate"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"contextMenu"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"copy"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"cut"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"doubleClick"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"drag"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"dragEnd"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"dragEnter"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"dragExit"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"dragLeave"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"dragOver"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"dragStart"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"drop"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"durationChange"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"emptied"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"encrypted"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"ended"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"error"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"focus"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"gotPointerCapture"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"input"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"invalid"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"keyDown"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"keyPress"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"keyUp"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"load"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"loadStart"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"loadedData"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"loadedMetadata"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"lostPointerCapture"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"mouseDown"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"mouseEnter"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"mouseLeave"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"mouseMove"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"mouseOut"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"mouseOver"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"mouseUp"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"paste"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"pause"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"play"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"playing"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"pointerCancel"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"pointerDown"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"pointerEnter"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"pointerLeave"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"pointerMove"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"pointerOut"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"pointerOver"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"pointerUp"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"progress"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"rateChange"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"reset"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"scroll"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"seeked"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"seeking"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"select"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"stalled"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"submit"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"suspend"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"timeUpdate"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"toggle"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"touchCancel"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"touchEnd"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"touchMove"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"touchStart"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"transitionEnd"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"volumeChange"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"waiting"</span>,
</div></li><li><div class="code-word">	  <span class="hljs-string">"wheel"</span>,
</div></li><li><div class="code-word">	]
</div></li></ol></code></pre></div>
<p data-nodeid="8390">在有了合成事件的基础后，就更容易理解后续的内容了。</p>
<h4 data-nodeid="8391">调用顺序</h4>
<p data-nodeid="8392">setState 是不是异步的？我们来从头梳理。</p>
<p data-nodeid="8393"><strong data-nodeid="8493">异步场景</strong></p>
<p data-nodeid="8394">通常我们认为 setState 是异步的，就像这样一个例子：</p>
<div class="course-code-area"><div class="copy-btn"><div class="copy-icon"></div>复制代码</div><pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{
</div></li><li><div class="code-word">&nbsp; &nbsp; state = {
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; &nbsp; count: <span class="hljs-number">0</span>
</div></li><li><div class="code-word">&nbsp; &nbsp; }
</div></li><li><div class="code-word">
</div></li><li><div class="code-word">&nbsp; &nbsp; componentDidMount(){
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">this</span>.setState({
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;count: <span class="hljs-number">1</span>
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}, () =&gt; {
</div></li><li><div class="code-word">            console.log(<span class="hljs-keyword">this</span>.state.count) <span class="hljs-comment">//1</span>
</div></li><li><div class="code-word">         })
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; &nbsp; console.log(<span class="hljs-keyword">this</span>.state.count) <span class="hljs-comment">// 0</span>
</div></li><li><div class="code-word">&nbsp; &nbsp; }
</div></li><li><div class="code-word">
</div></li><li><div class="code-word">&nbsp; &nbsp; render(){
</div></li><li><div class="code-word">&nbsp; &nbsp; &nbsp; &nbsp; ...
</div></li><li><div class="code-word">&nbsp; &nbsp; }
</div></li><li><div class="code-word">}
</div></li></ol></code></pre></div>
<p data-nodeid="8396">由于我们接受 setState 是异步的，所以会认为回调函数是异步回调，打出 0 的 console.log 会先执行，打出 1 的会后执行。</p>
<p data-nodeid="8397">那接下来这个案例的答案是什么呢？</p>
<div class="course-code-area"><div class="copy-btn"><div class="copy-icon"></div>复制代码</div><pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{
</div></li><li><div class="code-word">    state = {
</div></li><li><div class="code-word">        count: <span class="hljs-number">0</span>
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">
</div></li><li><div class="code-word">    componentDidMount(){
</div></li><li><div class="code-word">        <span class="hljs-keyword">this</span>.setState({
</div></li><li><div class="code-word">           count: <span class="hljs-keyword">this</span>.state.count + <span class="hljs-number">1</span>
</div></li><li><div class="code-word">         }, () =&gt; {
</div></li><li><div class="code-word">            console.log(<span class="hljs-keyword">this</span>.state.count)
</div></li><li><div class="code-word">         })
</div></li><li><div class="code-word">         <span class="hljs-keyword">this</span>.setState({
</div></li><li><div class="code-word">           count: <span class="hljs-keyword">this</span>.state.count + <span class="hljs-number">1</span>
</div></li><li><div class="code-word">         }, () =&gt; {
</div></li><li><div class="code-word">            console.log(<span class="hljs-keyword">this</span>.state.count)
</div></li><li><div class="code-word">         })
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">
</div></li><li><div class="code-word">    render(){
</div></li><li><div class="code-word">        ...
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">}
</div></li></ol></code></pre></div>
<p data-nodeid="8399">如果你觉得答案是 1,2，那肯定就错了。这种迷惑性极强的考题在面试中非常常见，因为它反直觉。</p>
<p data-nodeid="8400">如果重新仔细思考，你会发现当前拿到的 this.state.count 的值并没有变化，都是 0，所以输出结果应该是 1,1。</p>
<p data-nodeid="8401">当然，也可以在 setState 函数中获取修改后的 state 值进行修改。</p>
<div class="course-code-area"><div class="copy-btn"><div class="copy-icon"></div>复制代码</div><pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{
</div></li><li><div class="code-word">    state = {
</div></li><li><div class="code-word">        count: <span class="hljs-number">0</span>
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">
</div></li><li><div class="code-word">    componentDidMount(){
</div></li><li><div class="code-word">        <span class="hljs-keyword">this</span>.setState(
</div></li><li><div class="code-word">          preState=&gt; ({
</div></li><li><div class="code-word">            count:preState.count + <span class="hljs-number">1</span>
</div></li><li><div class="code-word">        }),()=&gt;{
</div></li><li><div class="code-word">           console.log(<span class="hljs-keyword">this</span>.state.count)
</div></li><li><div class="code-word">        })
</div></li><li><div class="code-word">        <span class="hljs-keyword">this</span>.setState(
</div></li><li><div class="code-word">          preState=&gt;({
</div></li><li><div class="code-word">            count:preState.count + <span class="hljs-number">1</span>
</div></li><li><div class="code-word">        }),()=&gt;{
</div></li><li><div class="code-word">           console.log(<span class="hljs-keyword">this</span>.state.count)
</div></li><li><div class="code-word">        })
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">
</div></li><li><div class="code-word">    render(){
</div></li><li><div class="code-word">        ...
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">}
</div></li></ol></code></pre></div>
<p data-nodeid="8403">这些通通是异步的回调，如果你以为输出结果是 1,2，那就又错了，实际上是 2,2。</p>
<p data-nodeid="8404">为什么会这样呢？当调用 setState 函数时，就会把当前的操作放入队列中。React 根据队列内容，合并 state 数据，完成后再逐一执行回调，根据结果更新虚拟 DOM，触发渲染。所以回调时，state 已经合并计算完成了，输出的结果就是 2,2 了。</p>
<p data-nodeid="8405">这非常反直觉，那为什么 React 团队选择了这样一个行为模式，而不是同步进行呢？一种常见的说法是为了优化。通过异步的操作方式，累积更新后，批量合并处理，减少渲染次数，提升性能。但同步就不能批量合并吗？这显然不能完全作为 setState 设计成异步的理由。</p>
<p data-nodeid="8406">在 17 年的时候就有人提出这样一个疑问“<a href="https://github.com/facebook/react/issues/11527" data-nodeid="8506">为什么 setState 是异步的</a>”，这个问题得到了官方团队的回复，原因有 2 个。</p>
<ul data-nodeid="8407">
<li data-nodeid="8408">
<p data-nodeid="8409"><strong data-nodeid="8512">保持内部一致性</strong>。如果改为同步更新的方式，尽管 setState 变成了同步，但是 props 不是。</p>
</li>
<li data-nodeid="8410">
<p data-nodeid="8411"><strong data-nodeid="8517">为后续的架构升级启用并发更新</strong>。为了完成异步渲染，React 会在 setState 时，根据它们的数据来源分配不同的优先级，这些数据来源有：事件回调句柄、动画效果等，再根据优先级并发处理，提升渲染性能。</p>
</li>
</ul>
<p data-nodeid="8412">从 React 17 的角度分析，异步的设计无疑是正确的，使异步渲染等最终能在 React 落地。那什么情况下它是同步的呢？</p>
<p data-nodeid="8413"><strong data-nodeid="8522">同步场景</strong></p>
<p data-nodeid="8414">异步场景中的案例使我们建立了这样一个认知：setState 是异步的，但下面这个案例又会颠覆你的认知。如果我们将 setState 放在 setTimeout 事件中，那情况就完全不同了。</p>
<div class="course-code-area"><div class="copy-btn"><div class="copy-icon"></div>复制代码</div><pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{
</div></li><li><div class="code-word">    state = {
</div></li><li><div class="code-word">        count: <span class="hljs-number">0</span>
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">
</div></li><li><div class="code-word">    componentDidMount(){
</div></li><li><div class="code-word">        <span class="hljs-keyword">this</span>.setState({ count: <span class="hljs-keyword">this</span>.state.count + <span class="hljs-number">1</span> });
</div></li><li><div class="code-word">        console.log(<span class="hljs-keyword">this</span>.state.count);
</div></li><li><div class="code-word">        setTimeout(() =&gt; {
</div></li><li><div class="code-word">          <span class="hljs-keyword">this</span>.setState({ count: <span class="hljs-keyword">this</span>.state.count + <span class="hljs-number">1</span> });
</div></li><li><div class="code-word">          console.log(<span class="hljs-string">"setTimeout: "</span> + <span class="hljs-keyword">this</span>.state.count);
</div></li><li><div class="code-word">        }, <span class="hljs-number">0</span>);
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">
</div></li><li><div class="code-word">    render(){
</div></li><li><div class="code-word">        ...
</div></li><li><div class="code-word">    }
</div></li><li><div class="code-word">}
</div></li></ol></code></pre></div>
<p data-nodeid="8416">那这时输出的应该是什么呢？如果你认为是 0,0，那么又错了。</p>
<p data-nodeid="8417">正确的结果是 0,2。因为 setState 并不是真正的异步函数，它实际上是通过队列延迟执行操作实现的，通过 isBatchingUpdates 来判断 setState 是先存进 state 队列还是直接更新。值为 true 则执行异步操作，false 则直接同步更新。</p>
<p data-nodeid="8418"><img src="https://s0.lgstatic.com/i/image2/M01/01/47/Cip5yF_YYfCAXIxiAAEJsQbj_hs785.png" alt="图片1.png" data-nodeid="8528"><br>
在 onClick、onFocus 等事件中，由于合成事件封装了一层，所以可以将 isBatchingUpdates 的状态更新为 true；在 React 的生命周期函数中，同样可以将 isBatchingUpdates 的状态更新为 true。那么在 React 自己的生命周期事件和合成事件中，可以拿到 isBatchingUpdates 的控制权，将状态放进队列，控制执行节奏。而在外部的原生事件中，并没有外层的封装与拦截，无法更新 isBatchingUpdates 的状态为 true。这就造成 isBatchingUpdates 的状态只会为 false，且立即执行。所以在 addEventListener&nbsp;、setTimeout、setInterval 这些原生事件中都会同步更新。</p>
<h3 data-nodeid="8419">回答</h3>
<p data-nodeid="8420">接下来我们可以答题了。</p>
<blockquote data-nodeid="8421">
<p data-nodeid="8422">setState 并非真异步，只是看上去像异步。在源码中，通过 isBatchingUpdates 来判断<br>
setState 是先存进 state 队列还是直接更新，如果值为 true 则执行异步操作，为 false 则直接更新。</p>
<p data-nodeid="8423">那么什么情况下 isBatchingUpdates 会为 true 呢？在 React 可以控制的地方，就为 true，比如在 React 生命周期事件和合成事件中，都会走合并操作，延迟更新的策略。</p>
<p data-nodeid="8424">但在 React 无法控制的地方，比如原生事件，具体就是在 addEventListener&nbsp;、setTimeout、setInterval 等事件中，就只能同步更新。</p>
<p data-nodeid="8425">一般认为，做异步设计是为了性能优化、减少渲染次数，React 团队还补充了两点。</p>
<ol data-nodeid="8426">
<li data-nodeid="8427">
<p data-nodeid="8428">保持内部一致性。如果将 state 改为同步更新，那尽管 state 的更新是同步的，但是 props不是。</p>
</li>
<li data-nodeid="8429">
<p data-nodeid="8430">启用并发更新，完成异步渲染。</p>
</li>
</ol>
</blockquote>
<p data-nodeid="8431">综上所述，我们可以整理出下面的知识导图。</p>
<p data-nodeid="8432"><img src="https://s0.lgstatic.com/i/image2/M01/01/3E/CgpVE1_YU2KAStLdAAFVKxh7Dyg317.png" alt="Drawing 7.png" data-nodeid="8544"></p>
<h3 data-nodeid="8433">进阶</h3>
<p data-nodeid="8434">这是一道经常会出现的 React setState 笔试题：下面的代码输出什么呢？</p>
<div class="course-code-area"><div class="copy-btn"><div class="copy-icon"></div>复制代码</div><pre><code data-language="java"><ol><li><div class="code-word"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
</div></li><li><div class="code-word">  state  = {
</div></li><li><div class="code-word">      count: <span class="hljs-number">0</span>
</div></li><li><div class="code-word">  };
</div></li><li><div class="code-word">
</div></li><li><div class="code-word">    componentDidMount() {
</div></li><li><div class="code-word">    <span class="hljs-keyword">this</span>.setState({count: <span class="hljs-keyword">this</span>.state.count + <span class="hljs-number">1</span>});
</div></li><li><div class="code-word">    console.log(<span class="hljs-keyword">this</span>.state.count);
</div></li><li><div class="code-word">
</div></li><li><div class="code-word">    <span class="hljs-keyword">this</span>.setState({count: <span class="hljs-keyword">this</span>.state.count + <span class="hljs-number">1</span>});
</div></li><li><div class="code-word">    console.log(<span class="hljs-keyword">this</span>.state.count);
</div></li><li><div class="code-word">
</div></li><li><div class="code-word">    setTimeout(() =&gt; {
</div></li><li><div class="code-word">      <span class="hljs-keyword">this</span>.setState({count: <span class="hljs-keyword">this</span>.state.count + <span class="hljs-number">1</span>});
</div></li><li><div class="code-word">      console.log(<span class="hljs-keyword">this</span>.state.count);
</div></li><li><div class="code-word">
</div></li><li><div class="code-word">      <span class="hljs-keyword">this</span>.setState({count: <span class="hljs-keyword">this</span>.state.count + <span class="hljs-number">1</span>});
</div></li><li><div class="code-word">      console.log(<span class="hljs-keyword">this</span>.state.count);
</div></li><li><div class="code-word">    }, <span class="hljs-number">0</span>);
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word"> 
</div></li><li><div class="code-word">  render() {
</div></li><li><div class="code-word">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
</div></li><li><div class="code-word">  }
</div></li><li><div class="code-word">};
</div></li></ol></code></pre></div>
<p data-nodeid="8436">我们可以进行如下的分析：</p>
<ul data-nodeid="8437">
<li data-nodeid="8438">
<p data-nodeid="8439">首先第一次和第二次的 console.log，都在 React 的生命周期事件中，所以是异步的处理方式，则输出都为 0；</p>
</li>
<li data-nodeid="8440">
<p data-nodeid="8441">而在 setTimeout 中的 console.log 处于原生事件中，所以会同步的处理再输出结果，但需要注意，虽然 count 在前面经过了两次的 this.state.count + 1，但是每次获取的 this.state.count 都是初始化时的值，也就是 0；</p>
</li>
<li data-nodeid="8442">
<p data-nodeid="8443">所以此时 count 是 1，那么后续在 setTimeout 中的输出则是 2 和 3。</p>
</li>
</ul>
<p data-nodeid="8444">所以完整答案是 0,0,2,3。</p>
<h3 data-nodeid="8445">总结</h3>
<p data-nodeid="8446">在本讲中，我们掌握了判断 setState 是同步还是异步的核心关键点：更新队列。不得不再强调一下，看 setState 的输出结果是面试的常考点。所以在面试前，可以再针对性的看一下这部分内容，然后自己执行几次试试。</p>
<p data-nodeid="9180">下一讲我将为你介绍另一个常考点，React 的跨组件通信。</p>
<p data-nodeid="9181"><a href="https://shenceyun.lagou.com/t/mka" data-nodeid="9189"><img src="https://s0.lgstatic.com/i/image/M00/72/94/Ciqc1F_EZ0eANc6tAASyC72ZqWw643.png" alt="Drawing 2.png" data-nodeid="9188"></a></p>
<p data-nodeid="9182">《大前端高薪训练营》</p>
<p data-nodeid="9183" class="te-preview-highlight">对标阿里 P7 技术需求 + 每月大厂内推，6 个月助你斩获名企高薪 Offer。<a href="https://shenceyun.lagou.com/t/mka" data-nodeid="9194">点击链接</a>，快来领取！</p></div></div>